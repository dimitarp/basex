
options {
  STATIC = false;
  JDK_VERSION = "1.7";
}

PARSER_BEGIN(UriParser)

package org.basex.query.util.uri.parse;

import static org.basex.util.Strings.UTF8;

import java.io.ByteArrayInputStream;

/**
 * A parser for RFC 3986 URIs.
 *
 * @author BaseX Team 2005-15, BSD License
 * @author Dimitar Popov
 */
public class UriParser {
  /**
   * Construct a new RFC 3986 URI parser.
   * @param uri the uri to parse
   */
  public UriParser(final byte[] uri) {
    this(new ByteArrayInputStream(uri), UTF8);
  }

  public static final class ParsedUri {
    public final String scheme;
    public final String authority;
    public final String userInfo;
    public final String host;
    public final int port;
    public final String path;
    public final String query;
    public final String fragment;

    private ParsedUri(String scheme, String authority, String userInfo, String host, int port, String path, String query, String fragment) {
      this.scheme = scheme;
      this.authority = authority;
      this.userInfo = userInfo;
      this.host = host;
      this.port = port;
      this.path = path;
      this.query = query;
      this.fragment = fragment;
    }

    @Override
    public String toString() {
      return "ParsedUri{" +
              "scheme='" + scheme + "'" +
              ", authority='" + authority + "'" +
              ", userInfo='" + userInfo + "'" +
              ", host='" + host + "'" +
              ", port=" + port +
              ", path='" + path + "'" +
              ", query='" + query + "'" +
              ", fragment='" + fragment + "'" +
              '}';
    }

    private static final class Builder {
      private String scheme;
      private String authority;
      private String userInfo;
      private String host;
      private int port = -1;
      private String path;
      private String query;
      private String fragment;

      Builder() {}

      public Builder scheme(String scheme) {
        this.scheme = scheme;
        return this;
      }

      public Builder authority(String authority) {
        this.authority = authority;
        return this;
      }

      public Builder userInfo(String userInfo) {
        this.userInfo = userInfo;
        return this;
      }

      public Builder host(String host) {
        this.host = host;
        return this;
      }

      public Builder port(int port) {
        this.port = port;
        return this;
      }

      public Builder path(String path) {
        this.path = path;
        return this;
      }

      public Builder query(String query) {
        this.query = query;
        return this;
      }

      public Builder fragment(String fragment) {
        this.fragment = fragment;
        return this;
      }

      public Builder but() {
        return new Builder()
            .authority(authority)
            .scheme(scheme)
            .host(host)
            .port(port)
            .path(path)
            .query(query)
            .fragment(fragment);
      }

      public ParsedUri build() {
        return new ParsedUri(
            scheme,
            authority,
            userInfo,
            host,
            port,
            path,
            query,
            fragment);
      }
    }
  }
}

PARSER_END(UriParser)


/**
 * RFC 2234: Augmented BNF for Syntax Specifications: ABNF
 */

/**
 * ALPHA = %x41-5A / %x61-7A ; A-Z / a-z
 */
TOKEN: {
  <ALPHA: ["A"-"Z", "a"-"z"]>
}

/**
 * DIGIT = %x30-39 ; 0-9
 */
TOKEN: {
  <DIGIT: ["0"-"9"]>
}

/**
 * HEXDIG =  DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
 */
TOKEN: {
  <HEXDIG: <DIGIT> | "A" | "B" | "C" | "D" | "E" | "F">
}



/**
 * RFC 3986: Uniform Resource Identifier (URI): Generic Syntax
 */

/**
 * <pre>pct-encoded = "%" HEXDIG HEXDIG</pre>
 */
TOKEN: {
  <PCT_ENCODED: "%" <HEXDIG> <HEXDIG>>
}

/**
 * <pre>
 * dec-octet = DIGIT                 ; 0-9
 *           / %x31-39 DIGIT         ; 10-99
 *           / "1" 2DIGIT            ; 100-199
 *           / "2" %x30-34 DIGIT     ; 200-249
 *           / "25" %x30-35          ; 250-255
 * </pre>
 */
TOKEN: {
  <DEC_OCTET: <DIGIT>
            | ["1"-"9"] <DIGIT>
            | "1" (<DIGIT>){2}
            | "2" ["0"-"4"] <DIGIT>
            | "25" ["0"-"4"]>
}

/**
 * <pre>IPv4address = dec-octet "." dec-octet "." dec-octet "." dec-octet</pre>
 */
//TOKEN: {
//  <IPv4_ADDRESS: <DEC_OCTET> "." <DEC_OCTET> "." <DEC_OCTET> "." <DEC_OCTET>>
//}

/**
 * <pre>ls32 = ( h16 ":" h16 ) / IPv4address</pre>
 */
//TOKEN: {
//  <LS32: (<H16> ":" <H16>) | <IPv4_ADDRESS>>
//}

/**
 * <pre>h16 = 1*4HEXDIG</pre>
 */
TOKEN: {
  <H16: (<HEXDIG>){1, 4}>
}

/**
 * <pre>
 * IPv6address =                            6( h16 ":" ) ls32
 *             /                       "::" 5( h16 ":" ) ls32
 *             / [               h16 ] "::" 4( h16 ":" ) ls32
 *             / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
 *             / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
 *             / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
 *             / [ *4( h16 ":" ) h16 ] "::"              ls32
 *             / [ *5( h16 ":" ) h16 ] "::"              h16
 *             / [ *6( h16 ":" ) h16 ] "::"
 * </pre>
 */
//TOKEN: {
//  <IPv6_ADDRESS:                                 (<H16> ":"){6} <LS32>
//               |                            "::" (<H16> ":"){5} <LS32>
//               | (                  <H16>)? "::" (<H16> ":"){4} <LS32>
//               | ((<H16> ":"){0, 1} <H16>)? "::" (<H16> ":"){3} <LS32>
//               | ((<H16> ":"){0, 2} <H16>)? "::" (<H16> ":"){2} <LS32>
//               | ((<H16> ":"){0, 3} <H16>)? "::"  <H16> ":"     <LS32>
//               | ((<H16> ":"){0, 4} <H16>)? "::"                <LS32>
//               | ((<H16> ":"){0, 5} <H16>)? "::"                <H16>
//               | ((<H16> ":"){0, 6} <H16>)? "::"
//               >
//}


  /**
   * Parse the given URI.
   * @return parsed URI
   * @throws ParseException if the provided URI is not RFC 3986 conformant.
   */
  ParsedUri parse() : {
    ParsedUri uri;
  } {
    uri = uriReference()
    {
      return uri;
    }
  }

  /**
   * <pre>URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]</pre>
   */
  ParsedUri.Builder uri(ParsedUri.Builder builder) : {
  } {
    scheme(builder) ":" hierPart(builder) [ "?" query(builder) ] [ "#" fragment(builder) ]
    {
      return builder;
    }
  }

  /**
   * <pre>
   * hier-part = "//" authority path-abempty
   *           / path-absolute
   *           / path-rootless
   *           / path-empty
   * </pre>
   */
  ParsedUri.Builder hierPart(ParsedUri.Builder builder) : {
  } {
    ( "//" authority(builder) pathAbempty(builder)
    | pathAbsolute(builder)
    | pathRootless(builder)
    | pathEmpty(builder) )
    {
      return builder;
    }
  }

  /**
   * <pre>URI-reference = URI / relative-ref</pre>
   */
  ParsedUri uriReference() : {
    ParsedUri.Builder builder = new ParsedUri.Builder();
  } {
    ( uri(builder) | relativeRef(builder) )
    {
      return builder.build();
    }
  }

  /**
   * <pre>absolute-URI  = scheme ":" hier-part [ "?" query ]</pre>
   */
  ParsedUri absoluteUri() : {
    ParsedUri.Builder builder = new ParsedUri.Builder();
  } {
    scheme(builder) ":" hierPart(builder) [ "?" query(builder) ]
    {
      return builder.build();
    }
  }

  /**
   * <pre>relative-ref = relative-part [ "?" query ] [ "#" fragment ]</pre>
   */
  ParsedUri.Builder relativeRef(ParsedUri.Builder builder) : {
  } {
    relativePart(builder) [ "?" query(builder) ] [ "#" fragment(builder) ]
    {
      return builder;
    }
  }

  /**
   * <pre>
   * relative-part = "//" authority path-abempty
   *               / path-absolute
   *               / path-noscheme
   *               / path-empty
   * </pre>
   */
  ParsedUri.Builder relativePart(ParsedUri.Builder builder) : {
  } {
    ( "//" authority(builder) pathAbempty(builder)
    | pathAbsolute(builder)
    | pathNoScheme(builder)
    | pathEmpty(builder) )
    {
      return builder;
    }
  }

  /**
   * <pre>scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." ) </pre>
   */
  ParsedUri.Builder scheme(ParsedUri.Builder builder) : {
  } {
    <ALPHA> ( <ALPHA> | <DIGIT> | "+" | "-" | "." )*
    {
      return builder.scheme(token.image);
    }
  }

  /**
   * <pre>authority = [ userinfo "@" ] host [ ":" port ]</pre>
   */
  ParsedUri.Builder authority(ParsedUri.Builder builder) : {
  } {
    [ userInfo(builder) "@" ] host(builder) [ ":" port(builder) ]
    {
      return builder;
    }
  }

  /**
   * <pre>userinfo = *( unreserved / pct-encoded / sub-delims / ":" )</pre>
   */
  ParsedUri.Builder userInfo(ParsedUri.Builder builder) : {
  } {
    ( unreserved() | <PCT_ENCODED> | subDelims() | ":" )*
    {
      return builder.userInfo(token.image);
    }
  }

  /**
   * <pre>host = IP-literal / IPv4address / reg-name</pre>
   */
  ParsedUri.Builder host(ParsedUri.Builder builder) : {
  } {
    ( ipLiteral() | ipv4Address() | regName() )
    {
      return builder.host(token.image);
    }
  }

  /**
   * <pre>port = *DIGIT</pre>
   */
  ParsedUri.Builder port(ParsedUri.Builder builder) : {
  } {
    ( <DIGIT> )*
    {
      if (token.image != null && token.image.length() > 0)
        builder.port(Integer.parseInt(token.image));
      return builder;
    }
  }

  /**
   * <pre>IP-literal = "[" ( IPv6address / IPvFuture  ) "]"</pre>
   */
  void ipLiteral() : {} {
    "[" ( ipv6Address() | ipvFuture() ) "]"
  }

  /**
   * <pre>IPvFuture = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )</pre>
   */
  void ipvFuture() : {} {
    "v" ( <HEXDIG> )+ "." ( unreserved() | subDelims() | ":" )+
  }

  /**
   * <pre>
   * IPv6address =                            6( h16 ":" ) ls32
   *             /                       "::" 5( h16 ":" ) ls32
   *             / [               h16 ] "::" 4( h16 ":" ) ls32
   *             / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
   *             / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
   *             / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
   *             / [ *4( h16 ":" ) h16 ] "::"              ls32
   *             / [ *5( h16 ":" ) h16 ] "::"              h16
   *             / [ *6( h16 ":" ) h16 ] "::"
   * </pre>
   */
  void ipv6Address() : {} {
    ( (                                    <(<H16> ":"){6}> ls32() )
    | (                               "::" <(<H16> ":"){5}> ls32() )
    | ( [                     <H16> ] "::" <(<H16> ":"){4}> ls32() )
    | ( [ <(<H16> ":"){0, 1}> <H16> ] "::" <(<H16> ":"){3}> ls32() )
    | ( [ <(<H16> ":"){0, 2}> <H16> ] "::" <(<H16> ":"){2}> ls32() )
    | ( [ <(<H16> ":"){0, 3}> <H16> ] "::"   <H16> ":"      ls32() )
    | ( [ <(<H16> ":"){0, 4}> <H16> ] "::"                  ls32() )
    | ( [ <(<H16> ":"){0, 5}> <H16> ] "::"                  <H16>  )
    | ( [ <(<H16> ":"){0, 6}> <H16> ] "::"                         )
    )
  }

  // TODO: h16

  /**
   * <pre>ls32 = ( h16 ":" h16 ) / IPv4address</pre>
   */
  void ls32() : {} {
    (<H16> ":" <H16>) | ipv4Address()
  }

  /**
   * <pre>IPv4address = dec-octet "." dec-octet "." dec-octet "." dec-octet</pre>
   */
  void ipv4Address() : {} {
    <DEC_OCTET> "." <DEC_OCTET> "." <DEC_OCTET> "." <DEC_OCTET>
  }

  // TODO




  /**
   * <pre>reg-name = *( unreserved / pct-encoded / sub-delims )</pre>
   */
  void regName() : {} {
    ( unreserved() | <PCT_ENCODED> | subDelims() )*
  }

  /**
   * <pre>
   * path = path-abempty    ; begins with "/" or is empty
   *      / path-absolute   ; begins with "/" but not "//"
   *      / path-noscheme   ; begins with a non-colon segment
   *      / path-rootless   ; begins with a segment
   *      / path-empty      ; zero characters
   * </pre>
   */
  ParsedUri.Builder path(ParsedUri.Builder builder) : {} {
    ( pathAbempty(builder)
    | pathAbsolute(builder)
    | pathNoScheme(builder)
    | pathRootless(builder)
    | pathEmpty(builder) )
    {
      return builder;
    }
  }

  /**
   * <pre>path-abempty  = *( "/" segment )</pre>
   */
  ParsedUri.Builder pathAbempty(ParsedUri.Builder builder) : {} {
    ( "/" segment() )*
    {
      return builder.path(token.image);
    }
  }

  /**
   * <pre>path-absolute = "/" [ segment-nz *( "/" segment ) ]</pre>
   */
  ParsedUri.Builder pathAbsolute(ParsedUri.Builder builder) : {} {
    "/" [ segmentNz() ( "/" segment() )* ]
    {
      return builder.path(token.image);
    }
  }

  /**
   * <pre>path-noscheme = segment-nz-nc *( "/" segment )</pre>
   */
  ParsedUri.Builder pathNoScheme(ParsedUri.Builder builder) : {} {
    segmentNzNc() ( "/" segment() )*
    {
      return builder.path(token.image);
    }
  }

  /**
   * <pre>path-rootless = segment-nz *( "/" segment )</pre>
   */
  ParsedUri.Builder pathRootless(ParsedUri.Builder builder) : {} {
    segmentNz() ( "/" segment() )*
    {
      return builder.path(token.image);
    }
  }

  /**
   * <pre>path-empty = 0<pchar></pre>
   */
  ParsedUri.Builder pathEmpty(ParsedUri.Builder builder) : {} {
    {}
    {
      return builder;
    }
  }

  /**
   * <pre>segment = *pchar</pre>
   */
  void segment() : {} {
    ( pchar() )*
  }

  /**
   * <pre>segment-nz = 1*pchar</pre>
   */
  void segmentNz() : {} {
    ( pchar() )+
  }

  /**
   * <pre>
   * segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / "@" )
   *                 ; non-zero-length segment without any colon ":"
   * </pre>
   */
  void segmentNzNc() : {} {
    ( unreserved() | <PCT_ENCODED> | subDelims() | "@" )+
  }

  /**
   * <pre>pchar = unreserved / pct-encoded / sub-delims / ":" / "@"</pre>
   */
  void pchar() : {} {
    unreserved() | <PCT_ENCODED> | subDelims() | ":" | "@"
  }

  /**
   * <pre>query = *( pchar / "/" / "?" )</pre>
   */
  ParsedUri.Builder query(ParsedUri.Builder builder) : {
  } {
    ( pchar() | "/" | "?" )*
    {
      return builder.query(token.image);
    }
  }

  /**
   * <pre>fragment = *( pchar / "/" / "?" )</pre>
   */
  ParsedUri.Builder fragment(ParsedUri.Builder builder) : {
  } {
    ( pchar() | "/" | "?" )*
    {
      return builder.fragment(token.image);
    }
  }

  // TODO pct-encoded

  /**
   * <pre>unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"</pre>
   */
  void unreserved() : {} {
    <ALPHA> | <DIGIT> | "-" | "." | "_" | "~"
  }

  /**
   * <pre>reserved = gen-delims / sub-delims</pre>
   */
  void reserved() : {} {
    genDelims() | subDelims()
  }

  /**
   * <pre>gen-delims = ":" / "/" / "?" / "#" / "[" / "]" / "@"</pre>
   */
  void genDelims() : {} {
    ":" | "/" | "?" | "#" | "[" | "]" | "@"
  }

  /**
   * <pre>
   * sub-delims = "!" / "$" / "&" / "'" / "(" / ")"
   *            / "*" / "+" / "," / ";" / "="
   * </pre>
   */
  void subDelims() : {} {
    "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "="
  }
